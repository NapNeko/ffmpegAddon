From 5834e5a12378648602d2f41a155e6b1ba83bdde9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=89=8B=E7=93=9C=E4=B8=80=E5=8D=81=E9=9B=AA?=
 <nanaeonn@outlook.com>
Date: Thu, 23 Oct 2025 00:12:09 +0800
Subject: [PATCH 5/8] Refactor and enhance SILK codec integration

Refactors both the SILK decoder and encoder wrappers to directly integrate the SILK SDK logic, update API usage, and improve buffer management. Updates include new internal decode/encode functions, revised callback handling, and modernized AVCodecContext field usage. Also updates codec registration structures and sample format declarations for better compatibility with FFmpeg's current API.
---
 libavcodec/silkdec.c | 148 +++++++++++++++++++++++++++++++++++--------
 libavcodec/silkenc.c | 114 +++++++++++++++++++++++++++++----
 2 files changed, 220 insertions(+), 42 deletions(-)

diff --git a/libavcodec/silkdec.c b/libavcodec/silkdec.c
index 18b8fccb4d..25884b5efe 100644
--- a/libavcodec/silkdec.c
+++ b/libavcodec/silkdec.c
@@ -1,26 +1,32 @@
-// FFmpeg Silk Decoder Wrapper
-#include "silkdec.h"
 #include "libavcodec/avcodec.h"
-#include "libavutil/common.h"
-#include "libavutil/mem.h"
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-
-
+#include "libavcodec/codec_id.h"
+#include "libavcodec/codec_internal.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libavcodec/codec_id.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_SDK_API.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_control.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_typedef.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_errors.h"
+#include <codec_id.h>
+#define SILK_SAMPLE_RATE 24000
+#define MAX_BYTES_PER_FRAME 250
+#define MAX_INPUT_FRAMES 5
+#define MAX_API_FS_KHZ 24
+#define FRAME_LENGTH_MS 20
+#define MAX_LBRR_DELAY 2
+// FFmpeg Silk Decoder Wrapper
 typedef struct SilkDecContext {
-    AVClass *class;
+    const AVClass *class;
     uint8_t *buffer;
     int buffer_size;
 } SilkDecContext;
 
 static void silk_ffmpeg_callback(void* userdata, const uint8_t* data, int size) {
     AVFrame *frame = (AVFrame*)userdata;
-    int old_size = frame->nb_samples * av_get_bytes_per_sample(frame->format) * frame->channels;
-    int new_samples = size / (frame->channels * av_get_bytes_per_sample(frame->format));
-    av_samples_alloc(frame->data, frame->linesize, frame->channels, frame->nb_samples + new_samples, frame->format, 1);
-    memcpy(frame->data[0] + old_size, data, size);
-    frame->nb_samples += new_samples;
+    // 假设 frame->data[0] 已分配足够空间
+    memcpy(frame->data[0], data, size);
+    frame->nb_samples = size / (av_get_bytes_per_sample(frame->format) * frame->ch_layout.nb_channels);
 }
 
 static av_cold int silk_decode_init(AVCodecContext *avctx) {
@@ -30,13 +36,97 @@ static av_cold int silk_decode_init(AVCodecContext *avctx) {
     return 0;
 }
 
-static int silk_decode_frame(AVCodecContext *avctx, AVFrame *frame,
-                            int *got_frame_ptr, AVPacket *pkt) {
-    SilkDecContext *s = avctx->priv_data;
-    frame->nb_samples = 0;
-    frame->channels = avctx->channels;
-    frame->format = avctx->sample_fmt;
-    silk_decode(pkt->data, pkt->size, silk_ffmpeg_callback, frame);
+
+static void ffmpeg_silk_decode(const uint8_t* silk_data, int data_len, void (*callback)(void*, const uint8_t*, int), void* userdata) {
+    SKP_uint8 payload[MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES * (MAX_LBRR_DELAY + 1)] = {0};
+    SKP_uint8* payloadEnd = payload;
+    SKP_int16 nBytesPerPacket[MAX_LBRR_DELAY + 1] = {0};
+    SKP_int16 nBytes = 0, totalLen = 0, len = 0;
+    SKP_int32 decSizeBytes = 0;
+    const uint8_t* psRead = silk_data;
+    void* psDec = NULL;
+    SKP_SILK_SDK_DecControlStruct dec_control = {0};
+    int remainPackets = 0;
+
+    // 跳过 magic
+    if (memcmp(psRead, "\x02#!SILK_V3", 9) != 0) return;
+    psRead += 9;
+
+    if (SKP_Silk_SDK_Get_Decoder_Size(&decSizeBytes)) return;
+    psDec = av_malloc(decSizeBytes);
+    if (!psDec) return;
+    if (SKP_Silk_SDK_InitDecoder(psDec)) { av_free(psDec); return; }
+
+    payloadEnd = payload;
+    dec_control.framesPerPacket = 1;
+    dec_control.API_sampleRate = SILK_SAMPLE_RATE;
+
+    for (int i = 0; i < MAX_LBRR_DELAY; i++) {
+        nBytes = *(const SKP_int16*)psRead;
+        psRead += sizeof(SKP_int16);
+        memcpy(payloadEnd, psRead, nBytes);
+        psRead += nBytes;
+        nBytesPerPacket[i] = nBytes;
+        payloadEnd += nBytes;
+    }
+    nBytesPerPacket[MAX_LBRR_DELAY] = 0;
+
+    while (1) {
+        SKP_int16 out[(FRAME_LENGTH_MS * MAX_API_FS_KHZ << 1) * MAX_INPUT_FRAMES] = {0};
+        if (remainPackets == 0) {
+            nBytes = *(const SKP_int16*)psRead;
+            psRead += sizeof(SKP_int16);
+            if (nBytes < 0 || psRead - silk_data >= data_len) {
+                remainPackets = MAX_LBRR_DELAY;
+                goto decode;
+            }
+            memcpy(payloadEnd, psRead, nBytes);
+            psRead += nBytes;
+        } else if (--remainPackets <= 0) {
+            break;
+        }
+    decode:
+        if (nBytesPerPacket[0] != 0) {
+            nBytes = nBytesPerPacket[0];
+        }
+        SKP_int16* outPtr = out;
+        totalLen = 0;
+        int frames = 0;
+        do {
+            SKP_Silk_SDK_Decode(psDec, &dec_control, 0, payload, nBytes, outPtr, &len);
+            frames++;
+            outPtr += len;
+            totalLen += len;
+            if (frames > MAX_INPUT_FRAMES) {
+                outPtr = out;
+                totalLen = 0;
+                frames = 0;
+            }
+        } while (dec_control.moreInternalDecoderFrames);
+        callback(userdata, (const uint8_t*)out, sizeof(SKP_int16) * totalLen);
+        SKP_int16 totBytes = 0;
+        for (int i = 0; i < MAX_LBRR_DELAY; i++) {
+            totBytes += nBytesPerPacket[i + 1];
+        }
+        if (totBytes < 0 || totBytes > sizeof(payload)) {
+            av_free(psDec);
+            return;
+        }
+        memmove(payload, &payload[nBytesPerPacket[0]], totBytes * sizeof(SKP_uint8));
+        payloadEnd -= nBytesPerPacket[0];
+        memmove(nBytesPerPacket, &nBytesPerPacket[1], MAX_LBRR_DELAY * sizeof(SKP_int16));
+    }
+    av_free(psDec);
+}
+
+static int silk_decode(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *pkt) {
+    AVFrame *frame = data;
+    // 预分配最大空间
+    frame->nb_samples = 480 * MAX_INPUT_FRAMES;
+    frame->format = AV_SAMPLE_FMT_S16;
+    av_channel_layout_default(&frame->ch_layout, 1);
+    av_frame_get_buffer(frame, 0);
+    ffmpeg_silk_decode(pkt->data, pkt->size, silk_ffmpeg_callback, frame);
     *got_frame_ptr = 1;
     return pkt->size;
 }
@@ -48,8 +138,8 @@ static av_cold int silk_decode_close(AVCodecContext *avctx) {
 }
 
 #define OFFSET(x) offsetof(SilkDecContext, x)
-#define AD AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_DECODING_PARAM
-static const AVOption silkdec_options[] = {
+#define AE AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+static const struct AVOption silkdec_options[] = {
     {NULL}
 };
 
@@ -60,16 +150,18 @@ static const AVClass silkdec_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
+static const enum AVSampleFormat silk_sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE };
+
 const FFCodec ff_silk_decoder = {
     .p.name           = "silk",
-    .p.long_name      = NULL_IF_CONFIG_SMALL("SILK audio decoder"),
+    .p.long_name      = "SILK audio decoder",
     .p.type           = AVMEDIA_TYPE_AUDIO,
-    .p.id             = AV_CODEC_ID_SILK,
+    .p.id             = AVCodecID.AV_CODEC_ID_SILK,
     .p.capabilities   = AV_CODEC_CAP_DR1,
     .priv_data_size   = sizeof(SilkDecContext),
     .init             = silk_decode_init,
-    .decode           = silk_decode_frame,
     .close            = silk_decode_close,
-    .p.sample_fmts    = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
+    FF_CODEC_DECODE_CB(silk_decode),
+    .p.sample_fmts    = silk_sample_fmts,
     .p.priv_class     = &silkdec_class,
 };
diff --git a/libavcodec/silkenc.c b/libavcodec/silkenc.c
index 7b3432563f..a56d89e493 100644
--- a/libavcodec/silkenc.c
+++ b/libavcodec/silkenc.c
@@ -1,16 +1,29 @@
 // FFmpeg Silk Encoder Wrapper
+
+
+#include "libavcodec/codec_id.h"
+#ifndef AV_CODEC_ID_SILK
+#define AV_CODEC_ID_SILK ((enum AVCodecID)0x16000) // 若已定义则无影响
+#endif
 #include "silkenc.h"
 #include "libavcodec/avcodec.h"
 #include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
 #include "libavutil/common.h"
 #include "libavutil/mem.h"
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
 
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_SDK_API.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_control.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_typedef.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_errors.h"
+#include <codec_id.h>
+
 
 typedef struct SilkEncContext {
-    AVClass *class;
+    const AVClass *class;
     uint8_t *buffer;
     int buffer_size;
 } SilkEncContext;
@@ -28,14 +41,84 @@ static av_cold int silk_encode_init(AVCodecContext *avctx) {
     return 0;
 }
 
-static int silk_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
-                            const AVFrame *frame, int *got_packet_ptr) {
-    SilkEncContext *s = avctx->priv_data;
-    int ret;
-    int input_size = frame->nb_samples * av_get_bytes_per_sample(avctx->sample_fmt) * avctx->channels;
-    uint8_t *input = (uint8_t*)frame->data[0];
-    av_new_packet(pkt, 0); // Start with empty packet
-    silk_encode(input, input_size, silk_ffmpeg_callback, pkt);
+
+
+// 直接集成 silk_encode 逻辑
+
+#define SILK_SAMPLE_RATE 24000
+#define MAX_BYTES_PER_FRAME 250
+#define MAX_INPUT_FRAMES 5
+#define MAX_API_FS_KHZ 24
+#define FRAME_LENGTH_MS 20
+
+static void ffmpeg_silk_encode(const uint8_t* pcm_data, int data_len, void (*callback)(void*, const uint8_t*, int), void* userdata) {
+    SKP_int16 in[FRAME_LENGTH_MS * MAX_API_FS_KHZ * MAX_INPUT_FRAMES] = {0};
+    SKP_uint8 payload[MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES] = {0};
+    SKP_int16 n_bytes;
+    SKP_int32 enc_size_bytes, result;
+    const uint8_t* ps_read = pcm_data;
+    const uint8_t* ps_read_end = pcm_data + data_len;
+    void* ps_enc = NULL;
+
+    SKP_int32 api_fs_hz = SILK_SAMPLE_RATE;
+    SKP_int32 max_internal_fs_hz = 24000;
+    SKP_int32 target_rate_bps = 24000;
+    SKP_int32 smpls_since_last_packet, packet_size_ms = 20;
+
+    SKP_SILK_SDK_EncControlStruct enc_status = {0};
+    SKP_SILK_SDK_EncControlStruct enc_control = {0};
+
+    enc_control.API_sampleRate = SILK_SAMPLE_RATE;
+    enc_control.maxInternalSampleRate = max_internal_fs_hz;
+    enc_control.packetSize = (packet_size_ms * SILK_SAMPLE_RATE) / 1000;
+    enc_control.packetLossPercentage = 0;
+    enc_control.useInBandFEC = 0;
+    enc_control.useDTX = 0;
+    enc_control.complexity = 2;
+    enc_control.bitRate = target_rate_bps > 0 ? target_rate_bps : 0;
+
+    callback(userdata, (const uint8_t*)"\x02#!SILK_V3", 9);
+
+    result = SKP_Silk_SDK_Get_Encoder_Size(&enc_size_bytes);
+    if (result) return;
+    ps_enc = av_malloc(enc_size_bytes);
+    if (!ps_enc) return;
+    result = SKP_Silk_SDK_InitEncoder(ps_enc, &enc_status);
+    if (result) { av_free(ps_enc); return; }
+
+    smpls_since_last_packet = 0;
+    while (ps_read < ps_read_end) {
+        size_t frame_size = 20 * api_fs_hz / 1000;
+        size_t realrd = frame_size * sizeof(SKP_int16);
+        if (realrd > (size_t)(ps_read_end - ps_read)) {
+            memset(in, 0, sizeof(in));
+            memcpy(in, ps_read, ps_read_end - ps_read);
+            ps_read += (ps_read_end - ps_read);
+        } else {
+            memcpy(in, ps_read, realrd);
+            ps_read += realrd;
+        }
+
+        n_bytes = MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES;
+        SKP_Silk_SDK_Encode(ps_enc, &enc_control, in, (SKP_int)frame_size, payload, &n_bytes);
+        packet_size_ms = 1000 * enc_control.packetSize / enc_control.API_sampleRate;
+
+        smpls_since_last_packet += (int)frame_size;
+        if (1000 * smpls_since_last_packet / api_fs_hz == packet_size_ms) {
+            callback(userdata, (const uint8_t*)&n_bytes, sizeof(SKP_int16));
+            callback(userdata, payload, n_bytes);
+            smpls_since_last_packet = 0;
+        }
+    }
+    av_free(ps_enc);
+}
+
+static int silk_encode(AVCodecContext *avctx, AVPacket *pkt,
+                       const AVFrame *frame, int *got_packet_ptr) {
+    int input_size = frame->nb_samples * av_get_bytes_per_sample(avctx->sample_fmt) * avctx->ch_layout.nb_channels;
+    const uint8_t *input = (const uint8_t*)frame->data[0];
+    av_new_packet(pkt, 0);
+    ffmpeg_silk_encode(input, input_size, silk_ffmpeg_callback, pkt);
     *got_packet_ptr = 1;
     return 0;
 }
@@ -46,9 +129,10 @@ static av_cold int silk_encode_close(AVCodecContext *avctx) {
     return 0;
 }
 
+
 #define OFFSET(x) offsetof(SilkEncContext, x)
 #define AE AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
-static const AVOption silkenc_options[] = {
+static const struct AVOption silkenc_options[] = {
     {NULL}
 };
 
@@ -59,16 +143,18 @@ static const AVClass silkenc_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
+static const enum AVSampleFormat silk_sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE };
+
 const FFCodec ff_silk_encoder = {
     .p.name           = "silk",
-    .p.long_name      = NULL_IF_CONFIG_SMALL("SILK audio encoder"),
+    .p.long_name      = "SILK audio encoder",
     .p.type           = AVMEDIA_TYPE_AUDIO,
-    .p.id             = AV_CODEC_ID_SILK,
+    .p.id             = AVCodecID.AV_CODEC_ID_SILK,
     .p.capabilities   = AV_CODEC_CAP_DR1,
     .priv_data_size   = sizeof(SilkEncContext),
     .init             = silk_encode_init,
-    .encode2          = silk_encode_frame,
     .close            = silk_encode_close,
-    .p.sample_fmts    = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
+    FF_CODEC_ENCODE_CB(silk_encode),
+    .p.sample_fmts    = silk_sample_fmts,
     .p.priv_class     = &silkenc_class,
 };
-- 
2.47.0.windows.2

