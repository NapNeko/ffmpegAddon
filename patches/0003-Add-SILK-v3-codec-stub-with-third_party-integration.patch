From 53d9dba6c0a75c0418f99c2b00298f2ddbe70950 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=89=8B=E7=93=9C=E4=B8=80=E5=8D=81=E9=9B=AA?=
 <nanaeonn@outlook.com>
Date: Thu, 23 Oct 2025 17:02:56 +0800
Subject: [PATCH 3/5] Add SILK v3 codec stub with third_party integration

Introduces a stub implementation for the SILK v3 audio codec, including encoder and decoder registration, a minimal adapter layer (silk_adapter.[ch]) to interface with the third_party SILK v3 decoder, and build system integration. Updates configure and Makefile to support the new codec and its dependencies, and adds necessary includes and object files for compilation. This lays the groundwork for full SILK v3 support in FFmpeg using bundled third_party sources.
---
 libavcodec/Makefile         |   2 +
 libavcodec/allcodecs.c      |   2 +
 libavcodec/codec_desc.c     |   7 +
 libavcodec/codec_id.h       |   3 +
 libavcodec/ntsilk_skp.c     |  27 ++++
 libavcodec/ntsilk_skp.h     |  21 +++
 libavcodec/ntsilk_skp_dec.c | 196 ++++++++++++++++++++++++++++
 libavcodec/ntsilk_skp_enc.c | 238 +++++++++++++++++++++++++++++++++
 libavformat/Makefile        |   6 +
 libavformat/allformats.c    |   8 ++
 libavformat/ntsilk.c        | 253 ++++++++++++++++++++++++++++++++++++
 11 files changed, 763 insertions(+)
 create mode 100644 libavcodec/ntsilk_skp.c
 create mode 100644 libavcodec/ntsilk_skp.h
 create mode 100644 libavcodec/ntsilk_skp_dec.c
 create mode 100644 libavcodec/ntsilk_skp_enc.c
 create mode 100644 libavformat/ntsilk.c

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 153a9e3881..57c830d73a 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -586,6 +586,8 @@ OBJS-$(CONFIG_MXPEG_DECODER)           += mxpegdec.o
 OBJS-$(CONFIG_NELLYMOSER_DECODER)      += nellymoserdec.o nellymoser.o
 OBJS-$(CONFIG_NELLYMOSER_ENCODER)      += nellymoserenc.o nellymoser.o
 OBJS-$(CONFIG_NOTCHLC_DECODER)         += notchlc.o
+OBJS-$(CONFIG_NTSILK_SKP_S16LE_DECODER) += ntsilk_skp.o ntsilk_skp_dec.o
+OBJS-$(CONFIG_NTSILK_SKP_S16LE_ENCODER) += ntsilk_skp.o ntsilk_skp_enc.o
 OBJS-$(CONFIG_NUV_DECODER)             += nuv.o rtjpeg.o jpegquanttables.o
 OBJS-$(CONFIG_ON2AVC_DECODER)          += on2avc.o on2avcdata.o
 OBJS-$(CONFIG_OPUS_DECODER)            += vorbis_data.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index aa0fc47647..3f34ba8590 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -505,6 +505,8 @@ extern const FFCodec ff_mpc8_decoder;
 extern const FFCodec ff_msnsiren_decoder;
 extern const FFCodec ff_nellymoser_encoder;
 extern const FFCodec ff_nellymoser_decoder;
+extern const FFCodec ff_ntsilk_skp_s16le_decoder;
+extern const FFCodec ff_ntsilk_skp_s16le_encoder;
 extern const FFCodec ff_on2avc_decoder;
 extern const FFCodec ff_opus_encoder;
 extern const FFCodec ff_opus_decoder;
diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
index d58c3d889c..6cb171c990 100644
--- a/libavcodec/codec_desc.c
+++ b/libavcodec/codec_desc.c
@@ -32,6 +32,13 @@
 #define MT(...) (const char *const[]){ __VA_ARGS__, NULL }
 
 static const AVCodecDescriptor codec_descriptors[] = {
+    {
+        .id        = AV_CODEC_ID_NTSILK_S16LE,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "ntsilk_s16le",
+        .long_name = NULL_IF_CONFIG_SMALL("NTSilk (s16le)"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
     /* video codecs */
     {
         .id        = AV_CODEC_ID_MPEG1VIDEO,
diff --git a/libavcodec/codec_id.h b/libavcodec/codec_id.h
index 0a8d3bed1e..4b287ab66c 100644
--- a/libavcodec/codec_id.h
+++ b/libavcodec/codec_id.h
@@ -545,6 +545,9 @@ enum AVCodecID {
     AV_CODEC_ID_QOA,
     AV_CODEC_ID_LC3,
 
+    /* Silk codec */
+    AV_CODEC_ID_NTSILK_S16LE = 0x15ff0,
+
     /* subtitle codecs */
     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
     AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
diff --git a/libavcodec/ntsilk_skp.c b/libavcodec/ntsilk_skp.c
new file mode 100644
index 0000000000..fe3483177b
--- /dev/null
+++ b/libavcodec/ntsilk_skp.c
@@ -0,0 +1,27 @@
+#include "../../silk-v3-decoder/silk/interface/SKP_Silk_errors.h"
+#include "ntsilk_skp.h"
+#include "libavutil/error.h"
+
+// Max avctx->bit_rate: 320 kbps, means 320 Kb data in 1s
+// Max FRAME_LENGTH_MS: 20ms    , means 50 frames   in 1s
+// => 320/50 = 6.4 Kb = 6400 b = 800 Bytes in one frame
+const size_t COMMON_MAX_BYTES_PER_FRAME = 800; // Equals peak bitrate of 320 kbps
+const size_t COMMON_FRAME_LENGTH_MS     = 20;
+const size_t COMMON_MAX_API_FS_KHZ      = 48;
+// Bake these values for compatibility with gcc < 8.1
+const size_t COMMON_MAX_INPUT_SIZE      = 960; // COMMON_FRAME_LENGTH_MS * COMMON_MAX_API_FS_KHZ
+const size_t COMMON_MAX_INPUT_SAMPLES   = 960; // COMMON_FRAME_LENGTH_MS * COMMON_MAX_API_FS_KHZ
+
+const size_t ENCODER_MAX_INPUT_FRAMES   = 1;
+const int16_t ENCODER_MAX_PAYLOAD_BYTES = 800; // COMMON_MAX_BYTES_PER_FRAME * ENCODER_MAX_INPUT_FRAMES
+const int16_t ENCODER_MAX_OUT_BYTES     = 802; // ENCODER_MAX_PAYLOAD_BYTES + 2 // sizeof(int16_t)
+
+const size_t DECODER_MAX_INPUT_FRAMES   = 5;
+
+int ff_ntsilk_error_to_averror(int err)
+{
+    switch (err) {
+    default:
+        return AVERROR(EINVAL);
+    }
+}
\ No newline at end of file
diff --git a/libavcodec/ntsilk_skp.h b/libavcodec/ntsilk_skp.h
new file mode 100644
index 0000000000..2a2cf10ecd
--- /dev/null
+++ b/libavcodec/ntsilk_skp.h
@@ -0,0 +1,21 @@
+#ifndef AVCODEC_NTSILK_SKP_H
+#define AVCODEC_NTSILK_SKP_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+extern const size_t COMMON_MAX_BYTES_PER_FRAME;
+extern const size_t COMMON_FRAME_LENGTH_MS;
+extern const size_t COMMON_MAX_API_FS_KHZ;
+extern const size_t COMMON_MAX_INPUT_SIZE;
+extern const size_t COMMON_MAX_INPUT_SAMPLES;
+
+extern const size_t ENCODER_MAX_INPUT_FRAMES;
+extern const int16_t ENCODER_MAX_PAYLOAD_BYTES;
+extern const int16_t ENCODER_MAX_OUT_BYTES;
+
+extern const size_t DECODER_MAX_INPUT_FRAMES;
+
+int ff_ntsilk_error_to_averror(int err);
+
+#endif /* AVCODEC_NTSILK_SKP_H */
\ No newline at end of file
diff --git a/libavcodec/ntsilk_skp_dec.c b/libavcodec/ntsilk_skp_dec.c
new file mode 100644
index 0000000000..a9bfb6504a
--- /dev/null
+++ b/libavcodec/ntsilk_skp_dec.c
@@ -0,0 +1,196 @@
+#include "../silk-v3-decoder/silk/interface/SKP_Silk_SDK_API.h"
+#include "libavutil/mem.h"
+#include "libavutil/opt.h"
+#include "libavutil/samplefmt.h"
+#include "codec_internal.h"
+#include "decode.h"
+#include "ntsilk_skp.h"
+
+const size_t MAX_BYTES_PER_FRAME = 1024;
+const size_t FRAME_LENGTH_MS     = 20;
+const size_t MAX_API_FS_KHZ      = 48;
+
+typedef struct NTSilkSKPDecoderContext {
+    const AVClass *class;
+    SKP_SILK_SDK_DecControlStruct dec_control;
+
+    void *dec;
+
+    // uint8_t payload[    MAX_BYTES_PER_FRAME * DECODER_MAX_INPUT_FRAMES * ( MAX_LBRR_DELAY + 1 ) ];
+    // uint8_t *payloadEnd = NULL;
+    // uint8_t *payloadToDec = NULL;
+    // uint8_t FECpayload[ MAX_BYTES_PER_FRAME * DECODER_MAX_INPUT_FRAMES ], *payloadPtr;
+    // int16_t nBytesPerPacket[ MAX_LBRR_DELAY + 1 ];
+    // int16_t totBytes;
+    // int16_t out[ ( ( FRAME_LENGTH_MS * MAX_API_FS_KHZ ) << 1 ) * DECODER_MAX_INPUT_FRAMES ], *outPtr;
+} NTSilkSKPDecoderContext;
+
+static int ntsilk_decode_s16le(AVCodecContext *avctx, AVFrame *frame,
+                               int *got_frame_ptr, AVPacket *avpkt)
+{
+    int err;
+    NTSilkSKPDecoderContext *sctx = avctx->priv_data;
+    int16_t len;
+    // int16_t n_bytes;
+    int16_t *out;
+    // int32_t frames = 0;
+
+    frame->nb_samples = COMMON_MAX_INPUT_SAMPLES; // 20ms * 48000Hz / 1000ms/s = 960 samples
+    err = ff_get_buffer(avctx, frame, 0);
+    if (err < 0) {
+        return err;
+    }
+
+    // n_bytes = *(int16_t *)avpkt->data;
+
+    // nBytesPerPacket[ MAX_LBRR_DELAY ] = n_bytes;
+    // payloadEnd += n_bytes;
+    // lost = 0;
+    // n_bytes = nBytesPerPacket[ 0 ];
+    // payloadToDec = payload;
+    // outPtr = out;
+    out = (int16_t *)frame->data[0];
+    frame->nb_samples = 0;
+    // frames = 0;
+    do {
+        /* Decode 20 ms */
+        err = SKP_Silk_SDK_Decode(
+            sctx->dec,
+            &sctx->dec_control,
+            0,
+            avpkt->data,
+            avpkt->size,
+            out,
+            &len
+            );
+        if (err) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Error decoding frame: %d\n", err);
+            return ff_ntsilk_error_to_averror(err);
+        }
+
+        // frames++;
+
+        // Unlike memcpy() etc., add len (offset) directly as data type's int16_t
+        out += len;
+        frame->nb_samples += len;
+
+        // if (frames > DECODER_MAX_INPUT_FRAMES) {
+        //     av_log(avctx, AV_LOG_WARNING,
+        //            "Corrupt stream detected\n");
+        //     out = (int16_t *)frame->data[0];
+        //     frame->nb_samples = 0;
+        //     frames = 0;
+        // }
+
+    } while(sctx->dec_control.moreInternalDecoderFrames);
+
+    // memcpy(frame->data[0], out, frame->nb_samples * 2);
+
+    // // Update buffer
+    // totBytes = 0;
+    // for (i = 0; i < MAX_LBRR_DELAY; i++) {
+    //     totBytes += nBytesPerPacket[i + 1];
+    // }
+    // memmove(payload, &payload[nBytesPerPacket[0]], totBytes * sizeof(uint8_t));
+    // payloadEnd -= nBytesPerPacket[0];
+    // memmove(nBytesPerPacket, &nBytesPerPacket[1], MAX_LBRR_DELAY * sizeof(int16_t));
+
+    *got_frame_ptr = 1;
+
+    return avpkt->size;
+}
+
+static av_cold int ntsilk_decode_init(AVCodecContext *avctx)
+{
+    int err;
+    NTSilkSKPDecoderContext *sctx = avctx->priv_data;
+    int32_t dec_size;
+
+    avctx->sample_rate = 24000;
+    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
+
+    sctx->dec_control.API_sampleRate = 24000;
+    // Initialize to one frame per packet,
+    // for proper concealment before first packet arrives
+    sctx->dec_control.framesPerPacket = 1;
+
+    err = SKP_Silk_SDK_Get_Decoder_Size(&dec_size);
+    if (err) {
+        av_log(avctx, AV_LOG_FATAL,
+               "Failed to create decoder: %d\n", err);
+        return ff_ntsilk_error_to_averror(err);
+    }
+
+    sctx->dec = av_malloc(dec_size);
+    if (!sctx->dec) {
+        av_log(avctx, AV_LOG_FATAL,
+               "Failed to alloc memory for encoder.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    err = SKP_Silk_SDK_InitDecoder(sctx->dec);
+    if (err) {
+        av_log(avctx, AV_LOG_FATAL,
+               "Failed to create decoder: %d\n", err);
+        return ff_ntsilk_error_to_averror(err);
+    }
+
+    // sctx->totBytes = 0;
+    // sctx->payloadEnd = sctx->payload;
+
+    return 0;
+}
+
+static av_cold int ntsilk_decode_close(AVCodecContext *avctx)
+{
+    NTSilkSKPDecoderContext *sctx = avctx->priv_data;
+
+    av_freep(&sctx->dec);
+
+    return 0;
+}
+
+static const AVOption ntsilkdec_options[] = {
+    {0},
+};
+
+static const AVClass ntsilkdec_class = {
+    .class_name = "NTSilk Decoder",
+    .item_name  = av_default_item_name,
+    .option     = ntsilkdec_options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const enum AVSampleFormat ntsilk_sample_fmts[] = {
+    AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE,
+};
+
+static const FFCodecDefault ntsilkdec_defaults[] = {
+    {0},
+};
+
+const FFCodec ff_ntsilk_skp_s16le_decoder = {
+    .p.name          = "ntsilk_s16le",
+    CODEC_LONG_NAME("NTSilk (s16le) Decoder using SILK SDK"),
+
+    .p.priv_class    = &ntsilkdec_class,
+    .priv_data_size  = sizeof(NTSilkSKPDecoderContext),
+
+    .p.type          = AVMEDIA_TYPE_AUDIO,
+    .p.id            = AV_CODEC_ID_NTSILK_S16LE,
+
+    .defaults        = ntsilkdec_defaults,
+
+    .init            = ntsilk_decode_init,
+    .close           = ntsilk_decode_close,
+    FF_CODEC_DECODE_CB(ntsilk_decode_s16le),
+
+    .p.capabilities  = AV_CODEC_CAP_DR1,
+    .caps_internal   = FF_CODEC_CAP_NOT_INIT_THREADSAFE
+                       | FF_CODEC_CAP_INIT_CLEANUP,
+
+    .p.sample_fmts   = ntsilk_sample_fmts,
+
+    .p.wrapper_name  = "skp",
+};
\ No newline at end of file
diff --git a/libavcodec/ntsilk_skp_enc.c b/libavcodec/ntsilk_skp_enc.c
new file mode 100644
index 0000000000..d41f65ffe7
--- /dev/null
+++ b/libavcodec/ntsilk_skp_enc.c
@@ -0,0 +1,238 @@
+#include "../../silk-v3-decoder/silk/interface/SKP_Silk_SDK_API.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/mem.h"
+#include "libavutil/opt.h"
+#include "libavutil/samplefmt.h"
+#include "codec_internal.h"
+#include "encode.h"
+#include "ntsilk_skp.h"
+
+// typedef struct NTSilkSKPEncoderOptions {
+// } NTSilkSKPEncoderOptions;
+
+typedef struct NTSilkSKPEncoderContext {
+    const AVClass *class;
+    SKP_SILK_SDK_EncControlStruct enc_control;
+    SKP_SILK_SDK_EncControlStruct enc_status;
+
+    void                          *enc;
+
+    // uint8_t in[COMMON_MAX_INPUT_SIZE];
+    // uint8_t out[ENCODER_MAX_PAYLOAD_BYTES];
+
+    // AudioFrameQueue afq;
+
+    // NTSilkSKPEncoderOptions opts;
+
+    // int32_t samples_since_last_packet;
+} NTSilkSKPEncoderContext;
+
+static int ntsilk_encode_s16le(struct AVCodecContext *avctx, struct AVPacket *avpkt,
+                               const struct AVFrame *frame, int *got_packet_ptr)
+{
+    int err;
+    NTSilkSKPEncoderContext *sctx = avctx->priv_data;
+    size_t counter;
+    int16_t n_bytes;
+
+    // frame is not null
+    counter = frame->nb_samples; // 20ms * 48000Hz / 1000ms/s = 960 samples
+
+    // // Cut the last audio samples that < 20ms
+    // if (counter < ((20 * sctx->enc_control.API_sampleRate) / 1000)) {
+    //     break;
+    // }
+
+    n_bytes = ENCODER_MAX_PAYLOAD_BYTES;
+
+    // 2 = s16 header
+    if ((err = ff_alloc_packet(avctx, avpkt, ENCODER_MAX_OUT_BYTES)) < 0)
+        return err;
+
+    err = SKP_Silk_SDK_Encode(
+        sctx->enc,
+        &sctx->enc_control,
+        (const int16_t *)frame->data[0],
+        counter,
+        avpkt->data + 2, // sizeof(int16_t)
+        &n_bytes); // Must use sctx.n_bytes and not avpkt->size as it's I/O par
+    if (err) {
+        av_log(avctx, AV_LOG_ERROR,
+             "Error encoding frame: %d\n", err);
+        return ff_ntsilk_error_to_averror(err);
+    }
+
+    // sctx->samples_since_last_packet += sctx->counter;
+
+    // if( ( ( 1000 * sctx->samples_since_last_packet ) / sctx->enc_control.API_sampleRate ) == 20 ) {
+    // Always true
+    memcpy(avpkt->data, &n_bytes, 2);
+
+    // sctx->samples_since_last_packet = 0;
+    // }
+
+    av_shrink_packet(avpkt, n_bytes + 2);
+
+    *got_packet_ptr = 1;
+
+    return 0;
+}
+
+// static av_cold void ntsilk_encode_flush(AVCodecContext *ctx)
+// {
+// }
+
+static av_cold int ntsilk_encode_init(AVCodecContext *avctx)
+{
+    int err;
+    NTSilkSKPEncoderContext *sctx = avctx->priv_data;
+    int32_t enc_size;
+
+    // Set encoder par
+    sctx->enc_control.API_sampleRate                 = avctx->sample_rate;                                 // Input sample rate
+    sctx->enc_control.maxInternalSampleRate          = 24000;                                              // Output sample rate
+    sctx->enc_control.packetSize = avctx->frame_size = 20 /* ms */ * avctx->sample_rate / 1000 /* s/ms */; // Input frame(packet) size
+    sctx->enc_control.packetLossPercentage           = 0;
+    sctx->enc_control.useInBandFEC                   = 0;
+    sctx->enc_control.useDTX                         = 0;
+    sctx->enc_control.complexity                     = 2;
+
+    // if (!avctx->bit_rate) {
+    //     sctx->enc_control.bitRate = avctx->bit_rate       = 25000;
+    //     av_log(avctx, AV_LOG_WARNING,
+    //            "No bit rate set. Defaulting to %"PRId64" bps.\n", avctx->bit_rate);
+    // }
+    // else {
+    //     sctx->enc_control.bitRate = avctx->bit_rate;
+    // }
+
+    // AF limit: 150 bytes
+    // Max bitrate:
+    // 150 (bytes) * 1000ms/s / 20ms = 7500byte = 60000bps
+    // To prevent data overflow, set target bitrate to 30000bps
+    sctx->enc_control.bitRate = avctx->bit_rate = 30000;
+
+    // Init encoder
+    err = SKP_Silk_SDK_Get_Encoder_Size(&enc_size);
+    if (err) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to create encoder: %d\n", err);
+        return ff_ntsilk_error_to_averror(err);
+    }
+
+    sctx->enc = av_malloc(enc_size);
+    if (!sctx->enc) {
+        av_log(avctx, AV_LOG_FATAL,
+               "Failed to alloc memory for encoder.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    err = SKP_Silk_SDK_InitEncoder(sctx->enc, &sctx->enc_status);
+    if (err) {
+        av_log(avctx, AV_LOG_FATAL,
+               "Failed to create encoder: %d\n", err);
+        return ff_ntsilk_error_to_averror(err);
+    }
+
+    // sctx->samples_since_last_packet = 0;
+
+    return 0;
+}
+
+static av_cold int ntsilk_encode_close(AVCodecContext *avctx)
+{
+    NTSilkSKPEncoderContext *sctx = avctx->priv_data;
+
+    av_freep(&sctx->enc);
+
+    return 0;
+}
+
+static const AVOption ntsilkenc_options[] = {
+    {0},
+};
+
+static const AVClass ntsilkenc_class = {
+    .class_name = "NTSilk Encoder",
+    .item_name  = av_default_item_name,
+    .option     = ntsilkenc_options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const int ntsilk_supported_samplerates[] = {
+    48000, 44100, 32000, 24000, 16000, 12000, 8000, 0,
+};
+
+static const AVChannelLayout ntsilk_ch_layouts[] = {
+    AV_CHANNEL_LAYOUT_MONO, {0},
+};
+
+static const enum AVSampleFormat ntsilk_sample_fmts[] = {
+    AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE,
+};
+
+static const FFCodecDefault ntsilkenc_defaults[] = {
+    {0},
+};
+
+const FFCodec ff_ntsilk_skp_s16le_encoder = {
+    .p.name                  = "ntsilk_s16le",
+    CODEC_LONG_NAME("NTSilk (s16le) Encoder using SILK SDK"),
+
+    .p.priv_class            = &ntsilkenc_class,
+    .priv_data_size          = sizeof(NTSilkSKPEncoderContext),
+
+    .p.type                  = AVMEDIA_TYPE_AUDIO,
+    .p.id                    = AV_CODEC_ID_NTSILK_S16LE,
+
+    .defaults                = ntsilkenc_defaults,
+
+    .init                    = ntsilk_encode_init,
+    .close                   = ntsilk_encode_close,
+    FF_CODEC_ENCODE_CB(ntsilk_encode_s16le),
+
+    .p.capabilities          = // Must use get_buffer() or get_encode_buffer()
+                               // for allocating buffers.
+                               //
+                               AV_CODEC_CAP_DR1
+                               //
+                               // NTSilk groups data as 20ms slices and will drop the last slice
+                               // when data size less than 20ms.
+                               //
+                               // The ntsilk_encode_xxxxx() calling
+                               // is very likely to get AVFrame with size less than 20ms.
+                               //
+                               // We use AFQ to temporarily store data in memory.
+                               // Each ntsilk_encode_xxxxx() calling will encode afq to <20ms.
+                               //
+                               // As a result, we automatically support variable AVFrame size.
+                               //
+                               // | AV_CODEC_CAP_SMALL_LAST_FRAME
+                               // | AV_CODEC_CAP_VARIABLE_FRAME_SIZE
+                               //
+                               // Since we have fixed the size of each AVPacket to 20ms,
+                               // another possible situation is -
+                               // if the size of the input AVFrame is larger than 20ms,
+                               // the data in AFQ will accumulate.
+                               //
+                               // To solve this problem, we must enable DELAY.
+                               // When DELAY is set,
+                               // libavcodec will repeatedly call ntsilk_encode_xxxxx()
+                               // without AVFrame, until there is no AVPacket output.
+                               // We use DELAY to encode the data accumulated in the AFQ.
+                               //
+                               // Note that this does not actually solve
+                               // the overflow problem.
+                               //
+                               // | AV_CODEC_CAP_DELAY
+                               ,
+
+    .caps_internal           = FF_CODEC_CAP_NOT_INIT_THREADSAFE
+                               | FF_CODEC_CAP_INIT_CLEANUP,
+
+    .p.supported_samplerates = ntsilk_supported_samplerates,
+    .p.ch_layouts            = ntsilk_ch_layouts,
+    .p.sample_fmts           = ntsilk_sample_fmts,
+
+    .p.wrapper_name          = "skp",
+};
\ No newline at end of file
diff --git a/libavformat/Makefile b/libavformat/Makefile
index 7ca68a7036..4b3fe2c0a0 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -222,6 +222,8 @@ OBJS-$(CONFIG_FLIC_DEMUXER)              += flic.o
 OBJS-$(CONFIG_FLV_DEMUXER)               += flvdec.o
 OBJS-$(CONFIG_LIVE_FLV_DEMUXER)          += flvdec.o
 OBJS-$(CONFIG_FLV_MUXER)                 += flvenc.o
+OBJS-$(CONFIG_SILK_DEMUXER)              += silkdemuxer.o
+OBJS-$(CONFIG_SILK_MUXER)                += silkmuxer.o
 OBJS-$(CONFIG_FOURXM_DEMUXER)            += 4xm.o
 OBJS-$(CONFIG_FRAMECRC_MUXER)            += framecrcenc.o framehash.o
 OBJS-$(CONFIG_FRAMEHASH_MUXER)           += hashenc.o framehash.o
@@ -410,6 +412,10 @@ OBJS-$(CONFIG_NC_DEMUXER)                += ncdec.o
 OBJS-$(CONFIG_NISTSPHERE_DEMUXER)        += nistspheredec.o pcm.o
 OBJS-$(CONFIG_NSP_DEMUXER)               += nspdec.o pcm.o
 OBJS-$(CONFIG_NSV_DEMUXER)               += nsvdec.o
+OBJS-$(CONFIG_NTSILK_SKP_S16LE_DEMUXER)  += ntsilk.o rawdec.o
+OBJS-$(CONFIG_NTSILK_SKP_S16LE_MUXER)    += ntsilk.o rawenc.o
+OBJS-$(CONFIG_NTSILK_TCT_S16LE_DEMUXER)  += ntsilk.o rawdec.o
+OBJS-$(CONFIG_NTSILK_TCT_S16LE_MUXER)    += ntsilk.o rawenc.o
 OBJS-$(CONFIG_NULL_MUXER)                += nullenc.o
 OBJS-$(CONFIG_NUT_DEMUXER)               += nutdec.o nut.o
 OBJS-$(CONFIG_NUT_MUXER)                 += nutenc.o nut.o
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index 305fa46532..55b4e71548 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -324,6 +324,10 @@ extern const FFInputFormat  ff_nc_demuxer;
 extern const FFInputFormat  ff_nistsphere_demuxer;
 extern const FFInputFormat  ff_nsp_demuxer;
 extern const FFInputFormat  ff_nsv_demuxer;
+extern const FFInputFormat  ff_ntsilk_skp_s16le_demuxer;
+extern const FFOutputFormat ff_ntsilk_skp_s16le_muxer;
+extern const FFInputFormat  ff_ntsilk_tct_s16le_demuxer;
+extern const FFOutputFormat ff_ntsilk_tct_s16le_muxer;
 extern const FFOutputFormat ff_null_muxer;
 extern const FFInputFormat  ff_nut_demuxer;
 extern const FFOutputFormat ff_nut_muxer;
@@ -576,6 +580,10 @@ extern const FFInputFormat  ff_libmodplug_demuxer;
 extern const FFInputFormat  ff_libopenmpt_demuxer;
 extern const FFInputFormat  ff_vapoursynth_demuxer;
 
+/* SILK */
+extern const FFInputFormat  ff_silk_demuxer;
+extern const FFOutputFormat ff_silk_muxer;
+
 #include "libavformat/muxer_list.c"
 #include "libavformat/demuxer_list.c"
 
diff --git a/libavformat/ntsilk.c b/libavformat/ntsilk.c
new file mode 100644
index 0000000000..1d4f6a2707
--- /dev/null
+++ b/libavformat/ntsilk.c
@@ -0,0 +1,253 @@
+#include "config_components.h"
+
+#include "libavutil/opt.h"
+#include "avformat.h"
+#include "avio_internal.h"
+#include "demux.h"
+#include "internal.h"
+#include "mux.h"
+#include "rawdec.h"
+#include "rawenc.h"
+
+static const uint8_t NTSILK_SKP_HEADER[9]  = "#!SILK_V3";
+static const uint8_t NTSILK_TCT_HEADER[10] = "\x02#!SILK_V3";
+
+typedef struct NTSilkDemuxerContext {
+    // int64_t pos;
+} NTSilkDemuxerContext;
+
+static int ntsilk_probe_skp(const AVProbeData *p)
+{
+    if (!memcmp(p->buf, NTSILK_SKP_HEADER, sizeof(NTSILK_SKP_HEADER)))
+        return AVPROBE_SCORE_MAX;
+    else
+        return 0;
+}
+
+static int ntsilk_probe_tct(const AVProbeData *p)
+{
+    if (!memcmp(p->buf, NTSILK_TCT_HEADER, sizeof(NTSILK_TCT_HEADER)))
+      return AVPROBE_SCORE_MAX;
+    else
+        return 0;
+}
+
+static int ntsilk_read_header_skp(AVFormatContext *s)
+{
+    NTSilkDemuxerContext *sctx = s->priv_data;
+    AVIOContext *pb = s->pb;
+    AVStream *st;
+    int64_t pos;
+
+    pos = avio_skip(pb, sizeof(NTSILK_SKP_HEADER));
+    if (pos < 0) {
+        return pos;
+    }
+
+    st = avformat_new_stream(s, NULL);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+    st->codecpar->codec_id    = AV_CODEC_ID_NTSILK_S16LE;
+    st->codecpar->sample_rate = 24000;
+    st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;
+    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
+    ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL_RAW;
+    st->start_time = 0;
+    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
+
+    // sctx->pos = 0;
+
+    return 0;
+}
+
+static int ntsilk_read_header_tct(AVFormatContext *s)
+{
+    NTSilkDemuxerContext *sctx = s->priv_data;
+    AVIOContext *pb = s->pb;
+    AVStream *st;
+    int64_t pos;
+
+    pos = avio_skip(pb, sizeof(NTSILK_TCT_HEADER));
+    if (pos < 0) {
+        return pos;
+    }
+
+    st = avformat_new_stream(s, NULL);
+    if (!st)
+        return AVERROR(ENOMEM);
+
+    st->codecpar->codec_id    = AV_CODEC_ID_NTSILK_S16LE;
+    st->codecpar->sample_rate = 24000;
+    st->codecpar->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;
+    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
+    ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL_RAW;
+    st->start_time = 0;
+    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
+
+    // sctx->pos = 0;
+
+    return 0;
+}
+
+static int ntsilk_read_packet_s16le(AVFormatContext *s, AVPacket *pkt)
+{
+    NTSilkDemuxerContext *sctx = s->priv_data;
+    int err;
+    AVIOContext *pb = s->pb;
+    int16_t n_bytes;
+
+    err = avio_read(pb, (uint8_t *)&n_bytes, 2);
+    if (err < 0) {
+        return err;
+    }
+
+    if (n_bytes <= 0) {
+        return 0;
+    }
+
+    err = av_new_packet(pkt, n_bytes);
+    if (err < 0) {
+        return err;
+    }
+
+    pkt->pos = avio_tell(pb);
+    pkt->stream_index = 0;
+    err = avio_read(pb, pkt->data, n_bytes);
+    if (err < 0) {
+        av_packet_unref(pkt);
+        return err;
+    }
+
+    return 0;
+}
+
+static int ntsilk_write_header_skp(AVFormatContext *s)
+{
+    AVIOContext *pb = s->pb;
+    avio_write(pb, NTSILK_SKP_HEADER, sizeof(NTSILK_SKP_HEADER));
+    return 0;
+}
+
+static int ntsilk_write_header_tct(AVFormatContext *s)
+{
+    AVIOContext *pb = s->pb;
+    avio_write(pb, NTSILK_TCT_HEADER, sizeof(NTSILK_TCT_HEADER));
+    return 0;
+}
+
+static int ntsilk_write_trailer_s16le(AVFormatContext *s)
+{
+    AVIOContext *pb = s->pb;
+    int16_t n = -1;
+    avio_write(pb, (const unsigned char *)&n, sizeof(int16_t));
+    return 0;
+}
+
+static const AVOption ntsilk_demuxer_options[] = {
+    {0},
+};
+
+static const AVClass ntsilk_demuxer_class = {
+    .class_name = "NTSilk Demuxer",
+    .item_name  = av_default_item_name,
+    .option     = ntsilk_demuxer_options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+#if CONFIG_NTSILK_SKP_S16LE_DEMUXER
+
+const FFInputFormat ff_ntsilk_skp_s16le_demuxer = {
+    .p.name            = "silk_s16le",
+    .p.long_name       = NULL_IF_CONFIG_SMALL("SILK (Skype)"),
+    .p.mime_type       = "audio/SILK",
+    .p.extensions      = "silk",
+
+    .p.priv_class      = &ntsilk_demuxer_class,
+    .priv_data_size    = sizeof(NTSilkDemuxerContext),
+
+    .p.flags           = AVFMT_NOTIMESTAMPS
+                         | AVFMT_GENERIC_INDEX,
+    .flags_internal    = FF_OFMT_FLAG_MAX_ONE_OF_EACH
+                         | FF_OFMT_FLAG_ONLY_DEFAULT_CODECS,
+
+    .read_probe        = ntsilk_probe_skp,
+    .read_header       = ntsilk_read_header_skp,
+    .read_packet       = ntsilk_read_packet_s16le,
+    // .read_packet       = ff_raw_read_partial_packet,
+    // .raw_codec_id      = AV_CODEC_ID_NTSILK_S16LE,
+};
+
+#endif /* CONFIG_NTSILK_SKP_S16LE_DEMUXER */
+
+#if CONFIG_NTSILK_TCT_S16LE_DEMUXER
+
+const FFInputFormat ff_ntsilk_tct_s16le_demuxer = {
+    .p.name            = "ntsilk_s16le",
+    .p.long_name       = NULL_IF_CONFIG_SMALL("NTSilk (Tencent)"),
+    .p.mime_type       = "audio/SILK",
+    .p.extensions      = "ntsilk",
+
+    .p.priv_class      = &ntsilk_demuxer_class,
+    .priv_data_size    = sizeof(NTSilkDemuxerContext),
+
+    .p.flags           = AVFMT_NOTIMESTAMPS
+                         | AVFMT_GENERIC_INDEX,
+    .flags_internal    = FF_OFMT_FLAG_MAX_ONE_OF_EACH
+                         | FF_OFMT_FLAG_ONLY_DEFAULT_CODECS,
+
+    .read_probe        = ntsilk_probe_tct,
+    .read_header       = ntsilk_read_header_tct,
+    .read_packet       = ntsilk_read_packet_s16le,
+    // .read_packet       = ff_raw_read_partial_packet,
+    // .raw_codec_id      = AV_CODEC_ID_NTSILK_S16LE,
+};
+
+#endif /* CONFIG_NTSILK_TCT_S16LE_DEMUXER */
+
+#if CONFIG_NTSILK_SKP_S16LE_MUXER
+
+const FFOutputFormat ff_ntsilk_skp_s16le_muxer = {
+    .p.name            = "silk_s16le",
+    .p.long_name       = NULL_IF_CONFIG_SMALL("SILK (Skype)"),
+    .p.mime_type       = "audio/SILK",
+    .p.extensions      = "silk",
+
+    .p.audio_codec     = AV_CODEC_ID_NTSILK_S16LE,
+    .p.video_codec     = AV_CODEC_ID_NONE,
+    .p.subtitle_codec  = AV_CODEC_ID_NONE,
+
+    .p.flags           = AVFMT_NOTIMESTAMPS
+                         | AVFMT_GENERIC_INDEX,
+    .flags_internal    = FF_OFMT_FLAG_MAX_ONE_OF_EACH
+                         | FF_OFMT_FLAG_ONLY_DEFAULT_CODECS,
+
+    .write_header      = ntsilk_write_header_skp,
+    .write_trailer     = ntsilk_write_trailer_s16le,
+    .write_packet      = ff_raw_write_packet,
+};
+
+#endif /* CONFIG_NTSILK_SKP_S16LE_MUXER */
+
+#if CONFIG_NTSILK_TCT_S16LE_MUXER
+
+const FFOutputFormat ff_ntsilk_tct_s16le_muxer = {
+    .p.name            = "ntsilk_s16le",
+    .p.long_name       = NULL_IF_CONFIG_SMALL("NTSilk (Tencent)"),
+    .p.mime_type       = "audio/SILK",
+    .p.extensions      = "ntsilk",
+
+    .p.audio_codec     = AV_CODEC_ID_NTSILK_S16LE,
+    .p.video_codec     = AV_CODEC_ID_NONE,
+    .p.subtitle_codec  = AV_CODEC_ID_NONE,
+
+    .p.flags           = AVFMT_NOTIMESTAMPS
+                         | AVFMT_GENERIC_INDEX,
+    .flags_internal    = FF_OFMT_FLAG_MAX_ONE_OF_EACH
+                         | FF_OFMT_FLAG_ONLY_DEFAULT_CODECS,
+
+    .write_header      = ntsilk_write_header_tct,
+    .write_packet      = ff_raw_write_packet,
+};
+
+#endif /* CONFIG_NTSILK_TCT_S16LE_MUXER */
\ No newline at end of file
-- 
2.47.0.windows.2

