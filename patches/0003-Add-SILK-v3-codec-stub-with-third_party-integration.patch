From 56722ae0613aaecb5a8340ba8b294d6416a57ad9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=89=8B=E7=93=9C=E4=B8=80=E5=8D=81=E9=9B=AA?=
 <nanaeonn@outlook.com>
Date: Thu, 23 Oct 2025 13:20:29 +0800
Subject: [PATCH 3/6] Add SILK v3 codec stub with third_party integration

Introduces a stub implementation for the SILK v3 audio codec, including encoder and decoder registration, a minimal adapter layer (silk_adapter.[ch]) to interface with the third_party SILK v3 decoder, and build system integration. Updates configure and Makefile to support the new codec and its dependencies, and adds necessary includes and object files for compilation. This lays the groundwork for full SILK v3 support in FFmpeg using bundled third_party sources.
---
 configure               |  16 ++++
 libavcodec/Makefile     |   2 +
 libavcodec/allcodecs.c  |   2 +
 libavcodec/codec_desc.c |   7 ++
 libavcodec/codec_id.h   |   3 +
 libavcodec/silkdec.c    | 172 ++++++++++++++++++++++++++++++++++++++++
 libavcodec/silkdec.h    |   9 +++
 libavcodec/silkenc.c    | 171 +++++++++++++++++++++++++++++++++++++++
 libavcodec/silkenc.h    |   9 +++
 9 files changed, 391 insertions(+)
 create mode 100644 libavcodec/silkdec.c
 create mode 100644 libavcodec/silkdec.h
 create mode 100644 libavcodec/silkenc.c
 create mode 100644 libavcodec/silkenc.h

diff --git a/configure b/configure
index 17eab51089..4a94d8a795 100755
--- a/configure
+++ b/configure
@@ -4029,6 +4029,7 @@ qsv_transcode_example_deps="avcodec avformat avutil h264_qsv_encoder"
 cpu_init_extralibs="pthreads_extralibs"
 cws2fws_extralibs="zlib_extralibs"
 
+
 # libraries, in any order
 avcodec_deps="avutil"
 avcodec_suggest="libm stdatomic liblcevc_dec"
@@ -4046,6 +4047,10 @@ swresample_suggest="libm libsoxr stdatomic"
 swscale_deps="avutil"
 swscale_suggest="libm stdatomic"
 
+# Silk codec option
+silk_deps="avcodec"
+
+
 avcodec_extralibs="pthreads_extralibs iconv_extralibs dxva2_extralibs lcms2_extralibs"
 avfilter_extralibs="pthreads_extralibs"
 avutil_extralibs="d3d11va_extralibs d3d12va_extralibs mediacodec_extralibs nanosleep_extralibs pthreads_extralibs vaapi_drm_extralibs vaapi_x11_extralibs vaapi_win32_extralibs vdpau_x11_extralibs"
@@ -4122,6 +4127,7 @@ fi
 cpu="generic"
 intrinsics="none"
 
+
 # configurable options
 enable $PROGRAM_LIST
 enable $DOCUMENT_LIST
@@ -4130,6 +4136,10 @@ enable $LIBRARY_LIST
 enable stripping
 enable version_tracking
 
+# Add silk to component list
+COMPONENT_LIST="$COMPONENT_LIST silk"
+
+
 enable asm
 enable debug
 enable doc
@@ -4351,6 +4361,12 @@ do_random(){
 for opt do
     optval="${opt#*=}"
     case "$opt" in
+        --enable-silk)
+            enable silk
+        ;;
+        --disable-silk)
+            disable silk
+        ;;
         --extra-ldflags=*)
             add_ldflags $optval
         ;;
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 153a9e3881..3d581c74e9 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -180,6 +180,8 @@ OBJS-$(CONFIG_WMA_FREQS)               += wma_freqs.o
 OBJS-$(CONFIG_WMV2DSP)                 += wmv2dsp.o
 
 # decoders/encoders
+OBJS-$(CONFIG_SILK_DECODER)              += silkdec.o
+OBJS-$(CONFIG_SILK_ENCODER)              += silkenc.o
 OBJS-$(CONFIG_ZERO12V_DECODER)         += 012v.o
 OBJS-$(CONFIG_A64MULTI_ENCODER)        += a64multienc.o elbg.o
 OBJS-$(CONFIG_A64MULTI5_ENCODER)       += a64multienc.o elbg.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index aa0fc47647..474390c537 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -418,6 +418,8 @@ extern const FFCodec ff_zmbv_encoder;
 extern const FFCodec ff_zmbv_decoder;
 
 /* audio codecs */
+extern const FFCodec ff_silk_encoder;
+extern const FFCodec ff_silk_decoder;
 extern const FFCodec ff_aac_encoder;
 extern const FFCodec ff_aac_decoder;
 extern const FFCodec ff_aac_fixed_decoder;
diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
index d58c3d889c..efdd3f21a1 100644
--- a/libavcodec/codec_desc.c
+++ b/libavcodec/codec_desc.c
@@ -32,6 +32,13 @@
 #define MT(...) (const char *const[]){ __VA_ARGS__, NULL }
 
 static const AVCodecDescriptor codec_descriptors[] = {
+        {
+            .id        = AV_CODEC_ID_SILK,
+            .type      = AVMEDIA_TYPE_AUDIO,
+            .name      = "silk",
+            .long_name = NULL_IF_CONFIG_SMALL("SILK Audio"),
+            .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+        },
     /* video codecs */
     {
         .id        = AV_CODEC_ID_MPEG1VIDEO,
diff --git a/libavcodec/codec_id.h b/libavcodec/codec_id.h
index 0a8d3bed1e..fcb02f8dc9 100644
--- a/libavcodec/codec_id.h
+++ b/libavcodec/codec_id.h
@@ -545,6 +545,9 @@ enum AVCodecID {
     AV_CODEC_ID_QOA,
     AV_CODEC_ID_LC3,
 
+    /* Silk codec */
+    AV_CODEC_ID_SILK,
+
     /* subtitle codecs */
     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
     AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
diff --git a/libavcodec/silkdec.c b/libavcodec/silkdec.c
new file mode 100644
index 0000000000..d66d611b6b
--- /dev/null
+++ b/libavcodec/silkdec.c
@@ -0,0 +1,172 @@
+#include "libavcodec/avcodec.h"
+#include "codec_id.h"
+#ifndef AV_CODEC_ID_SILK
+#define AV_CODEC_ID_SILK ((enum AVCodecID)0x16000)
+#endif
+#include "libavcodec/codec_internal.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libavutil/mem.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_SDK_API.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_control.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_typedef.h"
+#include "libavcodec/silk_v3_decoder/interface/SKP_Silk_errors.h"
+
+#define SILK_SAMPLE_RATE 24000
+#define MAX_BYTES_PER_FRAME 250
+#define MAX_INPUT_FRAMES 5
+#define MAX_API_FS_KHZ 24
+#define FRAME_LENGTH_MS 20
+#define MAX_LBRR_DELAY 2
+// FFmpeg Silk Decoder Wrapper
+typedef struct SilkDecContext {
+    const AVClass *class;
+    uint8_t *buffer;
+    int buffer_size;
+} SilkDecContext;
+
+static void silk_ffmpeg_callback(void* userdata, const uint8_t* data, int size) {
+    AVFrame *frame = (AVFrame*)userdata;
+    // 假设 frame->data[0] 已分配足够空间
+    memcpy(frame->data[0], data, size);
+    frame->nb_samples = size / (av_get_bytes_per_sample(frame->format) * frame->ch_layout.nb_channels);
+}
+
+static av_cold int silk_decode_init(AVCodecContext *avctx) {
+    SilkDecContext *s = avctx->priv_data;
+    s->buffer = NULL;
+    s->buffer_size = 0;
+    return 0;
+}
+
+
+static void ffmpeg_silk_decode(const uint8_t* silk_data, int data_len, void (*callback)(void*, const uint8_t*, int), void* userdata) {
+    SKP_uint8 payload[MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES * (MAX_LBRR_DELAY + 1)] = {0};
+    SKP_uint8* payloadEnd;
+    SKP_int16 nBytesPerPacket[MAX_LBRR_DELAY + 1] = {0};
+    SKP_int16 nBytes = 0, totalLen = 0, len = 0;
+    SKP_int32 decSizeBytes = 0;
+    const uint8_t* psRead = silk_data;
+    void* psDec = NULL;
+    SKP_SILK_SDK_DecControlStruct dec_control = {0};
+    int remainPackets = 0;
+    int frames = 0;
+    SKP_int16* outPtr = NULL;
+    SKP_int16 totBytes = 0;
+
+    // 跳过 magic
+    if (memcmp(psRead, "\x02#!SILK_V3", 9) != 0) return;
+    psRead += 9;
+
+    if (SKP_Silk_SDK_Get_Decoder_Size(&decSizeBytes)) return;
+    psDec = av_malloc(decSizeBytes);
+    if (!psDec) return;
+    if (SKP_Silk_SDK_InitDecoder(psDec)) { av_free(psDec); return; }
+
+    payloadEnd = payload;
+    dec_control.framesPerPacket = 1;
+    dec_control.API_sampleRate = SILK_SAMPLE_RATE;
+
+    for (int i = 0; i < MAX_LBRR_DELAY; i++) {
+        nBytes = *(const SKP_int16*)psRead;
+        psRead += sizeof(SKP_int16);
+        memcpy(payloadEnd, psRead, nBytes);
+        psRead += nBytes;
+        nBytesPerPacket[i] = nBytes;
+        payloadEnd += nBytes;
+    }
+    nBytesPerPacket[MAX_LBRR_DELAY] = 0;
+
+    while (1) {
+        SKP_int16 out[(FRAME_LENGTH_MS * MAX_API_FS_KHZ << 1) * MAX_INPUT_FRAMES] = {0};
+        if (remainPackets == 0) {
+            nBytes = *(const SKP_int16*)psRead;
+            psRead += sizeof(SKP_int16);
+            if (nBytes < 0 || psRead - silk_data >= data_len) {
+                remainPackets = MAX_LBRR_DELAY;
+                goto decode;
+            }
+            memcpy(payloadEnd, psRead, nBytes);
+            psRead += nBytes;
+        } else if (--remainPackets <= 0) {
+            break;
+        }
+    decode:
+        if (nBytesPerPacket[0] != 0) {
+            nBytes = nBytesPerPacket[0];
+        }
+        outPtr = out;
+        totalLen = 0;
+        frames = 0;
+        do {
+            SKP_Silk_SDK_Decode(psDec, &dec_control, 0, payload, nBytes, outPtr, &len);
+            frames++;
+            outPtr += len;
+            totalLen += len;
+            if (frames > MAX_INPUT_FRAMES) {
+                outPtr = out;
+                totalLen = 0;
+                frames = 0;
+            }
+        } while (dec_control.moreInternalDecoderFrames);
+        callback(userdata, (const uint8_t*)out, sizeof(SKP_int16) * totalLen);
+        totBytes = 0;
+        for (int i = 0; i < MAX_LBRR_DELAY; i++) {
+            totBytes += nBytesPerPacket[i + 1];
+        }
+        if (totBytes < 0 || totBytes > sizeof(payload)) {
+            av_free(psDec);
+            return;
+        }
+        memmove(payload, &payload[nBytesPerPacket[0]], totBytes * sizeof(SKP_uint8));
+        payloadEnd -= nBytesPerPacket[0];
+        memmove(nBytesPerPacket, &nBytesPerPacket[1], MAX_LBRR_DELAY * sizeof(SKP_int16));
+    }
+    av_free(psDec);
+}
+
+static int silk_decode(AVCodecContext *avctx, AVFrame *frame, int *got_frame_ptr, AVPacket *pkt) {
+    // 预分配最大空间
+    frame->nb_samples = 480 * MAX_INPUT_FRAMES;
+    frame->format = AV_SAMPLE_FMT_S16;
+    av_channel_layout_default(&frame->ch_layout, 1);
+    av_frame_get_buffer(frame, 0);
+    ffmpeg_silk_decode(pkt->data, pkt->size, silk_ffmpeg_callback, frame);
+    *got_frame_ptr = 1;
+    return pkt->size;
+}
+
+static av_cold int silk_decode_close(AVCodecContext *avctx) {
+    SilkDecContext *s = avctx->priv_data;
+    av_freep(&s->buffer);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(SilkDecContext, x)
+#define AE AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+static const struct AVOption silkdec_options[] = {
+    {NULL}
+};
+
+static const AVClass silkdec_class = {
+    .class_name = "silk decoder",
+    .item_name  = av_default_item_name,
+    .option     = silkdec_options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const enum AVSampleFormat silk_sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE };
+
+const FFCodec ff_silk_decoder = {
+    .p.name           = "silk",
+    .p.long_name      = "SILK audio decoder",
+    .p.type           = AVMEDIA_TYPE_AUDIO,
+    .p.id             = AV_CODEC_ID_SILK,
+    .p.capabilities   = AV_CODEC_CAP_DR1,
+    .priv_data_size   = sizeof(SilkDecContext),
+    .init             = silk_decode_init,
+    .close            = silk_decode_close,
+    FF_CODEC_DECODE_CB(silk_decode),
+    .p.sample_fmts    = silk_sample_fmts,
+    .p.priv_class     = &silkdec_class,
+};
diff --git a/libavcodec/silkdec.h b/libavcodec/silkdec.h
new file mode 100644
index 0000000000..28363e2301
--- /dev/null
+++ b/libavcodec/silkdec.h
@@ -0,0 +1,9 @@
+#ifndef FFMPEG_SILKDEC_H
+#define FFMPEG_SILKDEC_H
+
+#include "libavcodec/avcodec.h"
+#include "codec_internal.h"
+
+extern const FFCodec ff_silk_decoder;
+
+#endif // FFMPEG_SILKDEC_H
diff --git a/libavcodec/silkenc.c b/libavcodec/silkenc.c
new file mode 100644
index 0000000000..86ee842db6
--- /dev/null
+++ b/libavcodec/silkenc.c
@@ -0,0 +1,171 @@
+// FFmpeg Silk Encoder Wrapper
+
+#include "libavcodec/codec_id.h"
+#ifndef AV_CODEC_ID_SILK
+#define AV_CODEC_ID_SILK ((enum AVCodecID)0x16000) // 若已定义则无影响
+#endif
+#include "silkenc.h"
+#include "libavcodec/avcodec.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libavutil/common.h"
+#include "libavutil/mem.h"
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../../silk-v3-decoder/silk/interface/SKP_Silk_SDK_API.h"
+#include "../../silk-v3-decoder/silk/interface/SKP_Silk_control.h"
+#include "../../silk-v3-decoder/silk/interface/SKP_Silk_typedef.h"
+#include "../../silk-v3-decoder/silk/interface/SKP_Silk_errors.h"
+#include "codec_id.h"
+
+typedef struct SilkEncContext
+{
+    const AVClass *class;
+    uint8_t *buffer;
+    int buffer_size;
+} SilkEncContext;
+
+static void silk_ffmpeg_callback(void *userdata, const uint8_t *data, int size)
+{
+    AVPacket *pkt = (AVPacket *)userdata;
+    av_grow_packet(pkt, size);
+    memcpy(pkt->data + pkt->size - size, data, size);
+}
+
+static av_cold int silk_encode_init(AVCodecContext *avctx)
+{
+    SilkEncContext *s = avctx->priv_data;
+    s->buffer = NULL;
+    s->buffer_size = 0;
+    return 0;
+}
+
+// 直接集成 silk_encode 逻辑
+
+#define SILK_SAMPLE_RATE 24000
+#define MAX_BYTES_PER_FRAME 250
+#define MAX_INPUT_FRAMES 5
+#define MAX_API_FS_KHZ 24
+#define FRAME_LENGTH_MS 20
+
+static void ffmpeg_silk_encode(const uint8_t *pcm_data, int data_len, void (*callback)(void *, const uint8_t *, int), void *userdata)
+{
+    SKP_int16 in[FRAME_LENGTH_MS * MAX_API_FS_KHZ * MAX_INPUT_FRAMES] = {0};
+    SKP_uint8 payload[MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES] = {0};
+    SKP_int16 n_bytes;
+    SKP_int32 enc_size_bytes, result;
+    const uint8_t *ps_read = pcm_data;
+    const uint8_t *ps_read_end = pcm_data + data_len;
+    void *ps_enc = NULL;
+
+    SKP_int32 api_fs_hz = SILK_SAMPLE_RATE;
+    SKP_int32 max_internal_fs_hz = 24000;
+    SKP_int32 target_rate_bps = 24000;
+    SKP_int32 smpls_since_last_packet, packet_size_ms = 20;
+
+    SKP_SILK_SDK_EncControlStruct enc_status = {0};
+    SKP_SILK_SDK_EncControlStruct enc_control = {0};
+
+    enc_control.API_sampleRate = SILK_SAMPLE_RATE;
+    enc_control.maxInternalSampleRate = max_internal_fs_hz;
+    enc_control.packetSize = (packet_size_ms * SILK_SAMPLE_RATE) / 1000;
+    enc_control.packetLossPercentage = 0;
+    enc_control.useInBandFEC = 0;
+    enc_control.useDTX = 0;
+    enc_control.complexity = 2;
+    enc_control.bitRate = target_rate_bps > 0 ? target_rate_bps : 0;
+
+    callback(userdata, (const uint8_t *)"\x02#!SILK_V3", 9);
+
+    result = SKP_Silk_SDK_Get_Encoder_Size(&enc_size_bytes);
+    if (result)
+        return;
+    ps_enc = av_malloc(enc_size_bytes);
+    if (!ps_enc)
+        return;
+    result = SKP_Silk_SDK_InitEncoder(ps_enc, &enc_status);
+    if (result)
+    {
+        av_free(ps_enc);
+        return;
+    }
+
+    smpls_since_last_packet = 0;
+    while (ps_read < ps_read_end)
+    {
+        size_t frame_size = 20 * api_fs_hz / 1000;
+        size_t realrd = frame_size * sizeof(SKP_int16);
+        if (realrd > (size_t)(ps_read_end - ps_read))
+        {
+            memset(in, 0, sizeof(in));
+            memcpy(in, ps_read, ps_read_end - ps_read);
+            ps_read += (ps_read_end - ps_read);
+        }
+        else
+        {
+            memcpy(in, ps_read, realrd);
+            ps_read += realrd;
+        }
+
+        n_bytes = MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES;
+        SKP_Silk_SDK_Encode(ps_enc, &enc_control, in, (SKP_int)frame_size, payload, &n_bytes);
+        packet_size_ms = 1000 * enc_control.packetSize / enc_control.API_sampleRate;
+
+        smpls_since_last_packet += (int)frame_size;
+        if (1000 * smpls_since_last_packet / api_fs_hz == packet_size_ms)
+        {
+            callback(userdata, (const uint8_t *)&n_bytes, sizeof(SKP_int16));
+            callback(userdata, payload, n_bytes);
+            smpls_since_last_packet = 0;
+        }
+    }
+    av_free(ps_enc);
+}
+
+static int silk_encode(AVCodecContext *avctx, AVPacket *pkt,
+                       const AVFrame *frame, int *got_packet_ptr)
+{
+    int input_size = frame->nb_samples * av_get_bytes_per_sample(avctx->sample_fmt) * avctx->ch_layout.nb_channels;
+    const uint8_t *input = (const uint8_t *)frame->data[0];
+    av_new_packet(pkt, 0);
+    ffmpeg_silk_encode(input, input_size, silk_ffmpeg_callback, pkt);
+    *got_packet_ptr = 1;
+    return 0;
+}
+
+static av_cold int silk_encode_close(AVCodecContext *avctx)
+{
+    SilkEncContext *s = avctx->priv_data;
+    av_freep(&s->buffer);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(SilkEncContext, x)
+#define AE AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const struct AVOption silkenc_options[] = {
+    {NULL}};
+
+static const AVClass silkenc_class = {
+    .class_name = "silk encoder",
+    .item_name = av_default_item_name,
+    .option = silkenc_options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+static const enum AVSampleFormat silk_sample_fmts[] = {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE};
+
+const FFCodec ff_silk_encoder = {
+    .p.name = "silk",
+    .p.long_name = "SILK audio encoder",
+    .p.type = AVMEDIA_TYPE_AUDIO,
+    .p.id = AV_CODEC_ID_SILK,
+    .p.capabilities = AV_CODEC_CAP_DR1,
+    .priv_data_size = sizeof(SilkEncContext),
+    .init = silk_encode_init,
+    .close = silk_encode_close,
+    FF_CODEC_ENCODE_CB(silk_encode),
+    .p.sample_fmts = silk_sample_fmts,
+    .p.priv_class = &silkenc_class,
+};
diff --git a/libavcodec/silkenc.h b/libavcodec/silkenc.h
new file mode 100644
index 0000000000..5087440deb
--- /dev/null
+++ b/libavcodec/silkenc.h
@@ -0,0 +1,9 @@
+#ifndef FFMPEG_SILKENC_H
+#define FFMPEG_SILKENC_H
+
+#include "libavcodec/avcodec.h"
+#include "codec_internal.h"
+
+extern const FFCodec ff_silk_encoder;
+
+#endif // FFMPEG_SILKENC_H
-- 
2.47.0.windows.2

